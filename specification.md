# Техническое задание: Библиотека семейств Revit для FreeAxez

> **Интегрированная версия** от: 2026-02-16
> Цель: Создать спецификацию, которую ИИ может использовать для написания кода без дополнительных уточнений.
>
> **Включает:**
> - Основное ТЗ (User Stories, Модули)
> - Технические решения (хеширование, Extensible Storage, Worksharing)
> - System Families (классификация групп A-E, фазовый план)
> - Nested Families (Shared/Non-Shared, зависимости)

---

## 1. Контекст и введение

### 1.1 Что это за система

Family Library для компании FreeAxez, работающая в тесной связи с корпоративным шаблоном проекта Revit (.rte). Система вводит понятие функциональной роли семейства, что позволяет идентифицировать и отслеживать семейства независимо от изменений их названий между версиями шаблона. Включает версионирование, централизованное хранение и инструменты распознавания семейств в старых проектах.

### 1.2 Для кого (Стейкхолдеры)

Система имеет три роли пользователей с иерархией прав: всё, что доступно более низкой роли, доступно и более высокой.

| Роль | Права |
|------|-------|
| **Проектировщик** | Просмотр библиотеки, загрузка семейств в проект |
| **БИМ-менеджер** | Всё от Проектировщика + привязка семейств к ролям, клеймление, загрузка семейств в библиотеку, сканирование проектов |
| **Администратор** | Всё от БИМ-менеджера + создание/редактирование/удаление ролей, тегов, категорий, настройка правил распознавания. По сути — разработчик плагина. Администраторов может быть несколько. |

**Важно:** БИМ-менеджер не имеет доступа к созданию ролей — все роли создаются через Администратора.

### 1.3 Какую проблему решает

Система решает три ключевые проблемы:

1. **Проблема распознавания при смене имён**
   В разных версиях корпоративного шаблона имена семейств могут меняться. Плагин перестаёт распознавать одно и то же семейство, если его название изменилось. Решение: введение неизменяемой функциональной роли, которая "прошивается" в семейство.

2. **Проблема версионирования**
   Нет контроля за изменениями в семействах. Непонятно, какая версия семейства используется в проекте, и есть ли обновления. Решение: глубокий SHA256-хеш на основе геометрии и параметров, отслеживание версий в центральном репозитории.

3. **Проблема каталогизации**
   Нет централизованной библиотеки семейств. Проектировщики используют разные версии, хаос в файлах. Решение: единая Family Library с метаданными, превью и инструментами поиска.

### 1.4 Глоссарий

| Термин | Определение |
|--------|-------------|
| **Роль (FamilyRole)** | Неизменяемый идентификатор семейства в библиотеке. Пример: `FreeAxez_Table`. Связывает семейство с библиотекой независимо от имени файла. |
| **Stamp (Клеймление)** | Запись метаданных (RoleName, ContentHash) в Extensible Storage семейства. Локальная операция, не требует сети. |
| **Publish (Публикация)** | Загрузка семейства в библиотеку (Azure Blob + база данных). Требует сеть, создаёт новую версию. |
| **ContentHash** | Гибридный SHA256 хеш (PartAtom XML + OLE Structured Storage streams). Идентифицирует содержимое семейства без учёта имени файла. |
| **Legacy Recognition** | Распознавание семейств по правилам анализа имён. Применяется к семействам без клейма (старые проекты). |
| **Loadable Family** | Семейство из .rfa файла. Редактируется в Family Editor. Загружается в проект. |
| **System Family** | Встроенный тип Revit (Wall, Floor, Pipe и др.). Нет .rfa файла. Хранится как JSON в библиотеке. |
| **Nested Family** | Вложенное семейство. Shared — видно отдельно, Non-Shared — часть родительского. |
| **Type Catalog** | TXT файл с типоразмерами. Позволяет загрузить только выбранные типы из семейства. |
| **Extensible Storage (ES)** | Механизм Revit для хранения кастомных данных в элементах. Используется для записи клейма. |
| **Draft** | Временная запись в базе для семейств в очереди на публикацию. Удаляется после Publish. |
| **Pull Update** | Загрузка обновления семейства из библиотеки в проект. |
| **Snapshot** | JSON-снимок состояния семейства при Publish. Используется для diff/changelog. |
| **Azurite** | Локальный эмулятор Azure Blob Storage. Используется в MVP вместо реального Azure. |

---

## 2. Технический контекст и интеграции

### 2.1 Архитектура и стек

| Компонент | Технология |
|-----------|------------|
| Плагин | Autodesk Revit (C#), шаблон nicetreePoint, Revit 2020-2026 |
| UI | SPA на Angular 21 + PrimeNG + Tailwind CSS |
| Backend | .NET 10 + SQL Server 2025 |
| Хранение файлов | Azure Blob |
| Локальное хранение | Revit Extensible Storage |

**MVP: Azurite для локальной разработки**

Для MVP и локальной разработки используется **Azurite** — эмулятор Azure Blob Storage:
- Полная совместимость с Azure Blob API
- Запускается локально (Docker или npm)
- Нет затрат на Azure в процессе разработки
- Лёгкий переход на реальный Azure (только connection string)

```
# MVP / Development
ConnectionStrings:AzureBlob=DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;

# Production
ConnectionStrings:AzureBlob=DefaultEndpointsProtocol=https;AccountName=freeaxezfamilylib;AccountKey=...;EndpointSuffix=core.windows.net
```

### 2.2 Режимы работы UI

- **Встроенный режим** — работает в WebView2 внутри Revit
- **Автономный режим** — работает в браузере (функционал без данных из Revit)

### 2.3 Интеграционные точки

#### 2.3.1 API контракты (Плагин ↔ Бэкенд)

| Endpoint | Метод | Описание |
|----------|-------|----------|
| `/api/roles` | GET | Получить все роли (с фильтром по Type: Loadable/System) |
| `/api/roles` | POST | Создать роль (одиночно или пакетно) |
| `/api/roles/{id}` | PUT | Обновить роль (только Description, Category, Tags) |
| `/api/roles/{id}` | DELETE | Удалить роль (только если нет привязанных семейств) |
| `/api/roles/import` | POST | Импорт ролей из Excel |
| `/api/categories` | GET/POST/PUT/DELETE | CRUD категорий |
| `/api/tags` | GET/POST/PUT/DELETE | CRUD тегов |
| `/api/recognition-rules` | GET/POST/PUT/DELETE | CRUD правил распознавания |
| `/api/recognition-rules/validate` | POST | Валидация формулы + проверка конфликтов |
| `/api/recognition-rules/test` | POST | Тест правила на имени семейства |
| `/api/families` | GET | Поиск семейств в библиотеке (фильтры, пагинация) |
| `/api/families/{id}` | GET | Детали семейства + история версий |
| `/api/families/{id}/versions` | GET | Список версий |
| `/api/families/{id}/download/{version}` | GET | Скачать RFA (+ TXT если есть) |
| `/api/families/publish` | POST | Загрузить семейство в библиотеку (RFA + TXT + метаданные) |
| `/api/families/validate-hash` | POST | Проверить Hash на дубликаты |
| `/api/families/batch-check` | POST | Массовая проверка статусов (по списку RoleName + Hash) |
| `/api/system-types` | GET/POST | CRUD для System Types (JSON-данные) |
| `/api/drafts` | GET/POST/DELETE | Управление Drafts (очередь публикации) |

#### 2.3.2 WebView2 ↔ Revit Plugin

| Событие | Направление | Описание |
|---------|-------------|----------|
| `revit:ready` | Plugin → UI | Плагин готов, передаёт контекст (projectId, userRole) |
| `revit:families:list` | Plugin → UI | Список семейств из проекта |
| `revit:system-types:list` | Plugin → UI | Список System Types из проекта |
| `ui:stamp` | UI → Plugin | Запрос на Stamp (familyId, roleName) |
| `ui:publish` | UI → Plugin | Запрос на Publish (familyId) |
| `ui:load-family` | UI → Plugin | Загрузить семейство в проект |
| `ui:update-family` | UI → Plugin | Обновить семейство из библиотеки |
| `revit:operation-complete` | Plugin → UI | Результат операции (success/error) |

#### 2.3.3 Azure Blob структура

> **MVP:** Используется Azurite (localhost:10000). Переход на production = смена connection string.

**Структура хранения в Blob:**

```
container: family-library/
├── families/
│   ├── {roleName}/
│   │   ├── v1/
│   │   │   ├── family.rfa              ← системное имя (фиксированное)
│   │   │   └── catalog.txt (optional)  ← системное имя (фиксированное)
│   │   ├── v2/
│   │   │   └── ...
├── previews/
│   ├── {familyId}_v{version}.png
```

**Оригинальное имя файла хранится в базе данных:**

```json
// FamilyVersion table
{
  "familyId": "guid",
  "version": 1,
  "blobPath": "families/FreeAxez_Table/v1/family.rfa",
  "catalogBlobPath": "families/FreeAxez_Table/v1/catalog.txt",
  "originalFileName": "FreeAxez_Table_2024.rfa",    // ← оригинальное имя RFA
  "originalCatalogName": "FreeAxez_Table_2024.txt"  // ← оригинальное имя TXT
}
```

**Логика скачивания для пользователя:**

1. Скачать `family.rfa` из Blob
2. Скачать `catalog.txt` из Blob (если есть)
3. Переименовать:
   - `family.rfa` → `{originalFileName}` (например, `FreeAxez_Table_2024.rfa`)
   - `catalog.txt` → `{originalCatalogName}` (например, `FreeAxez_Table_2024.txt`)
4. Отдать пользователю

**Результат:** пользователь получает файлы с оригинальными именами семейства.

#### 2.3.4 Мультитаргетинг плагина

| Версия Revit | .NET Runtime | WebView2 |
|--------------|--------------|----------|
| 2020-2024 | .NET Framework 4.8 | NuGet пакет |
| 2025-2026 | .NET 8 | NuGet пакет |

**Требуется:** две сборки плагина или conditional compilation.

### 2.4 Dependencies

#### 2.4.1 NuGet пакеты (Плагин)

| Пакет | Версия | Назначение |
|-------|--------|------------|
| `Revit_API` | 2020-2026 | Revit API (две версии для .NET Framework 4.8 и .NET 8) |
| `Microsoft.Web.WebView2` | 1.0.+ | WebView2 для UI |
| `Newtonsoft.Json` | 13.0.+ | JSON сериализация |
| `Azure.Storage.Blobs` | 12.+ | Работа с Azure Blob (или Azurite) |

#### 2.4.2 NuGet пакеты (Backend)

| Пакет | Версия | Назначение |
|-------|--------|------------|
| `Microsoft.EntityFrameworkCore` | 9.+ | ORM |
| `Microsoft.EntityFrameworkCore.SqlServer` | 9.+ | SQL Server провайдер |
| `Azure.Storage.Blobs` | 12.+ | Azure Blob Storage |
| `Microsoft.AspNetCore.Authentication.JwtBearer` | 9.+ | JWT аутентификация |
| `Swashbuckle.AspNetCore` | 6.+ | Swagger/OpenAPI |

#### 2.4.3 NPM пакеты (Frontend)

| Пакет | Версия | Назначение |
|-------|--------|------------|
| `@angular/core` | 21+ | Angular framework |
| `primeng` | 19+ | UI компоненты |
| `tailwindcss` | 4+ | CSS фреймворк |
| `@tanstack/virtual` | 3+ | Virtual scroll |

#### 2.4.4 Внешние сервисы

| Сервис | MVP | Production |
|--------|-----|------------|
| Blob Storage | Azurite (localhost) | Azure Blob Storage |
| Database | SQL Server Express / LocalDB | Azure SQL |
| Authentication | Mock / Local | Azure AD |
| Frontend hosting | localhost | Azure Static Web Apps |

#### 2.4.5 Infrastructure Dependencies

| Компонент | Требование |
|-----------|------------|
| **Edge WebView2 Runtime** | Должен быть установлен на машине пользователя (встроен в Windows 11) |
| **SQL Server** | 2019+ или Azure SQL |
| **Docker** | Для Azurite в контейнере (опционально) |
| **.NET Runtime** | 4.8 (Revit 2020-2024) или .NET 8 (Revit 2025-2026) |

#### 2.4.6 Dependency Graph

```
┌─────────────────────────────────────────────────────────────┐
│                        Frontend (Angular)                    │
│  ┌─────────┐  ┌──────────┐  ┌───────────┐  ┌─────────────┐  │
│  │ Angular │  │ PrimeNG  │  │ Tailwind  │  │ Virtual     │  │
│  └────┬────┘  └────┬─────┘  └─────┬─────┘  └──────┬──────┘  │
└───────┼────────────┼──────────────┼───────────────┼─────────┘
        │            │              │               │
        └────────────┴──────────────┴───────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Backend API (.NET 10)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐    │
│  │ EF Core      │  │ Azure Blob   │  │ JWT Auth        │    │
│  └──────┬───────┘  └──────┬───────┘  └────────┬────────┘    │
└─────────┼─────────────────┼───────────────────┼─────────────┘
          │                 │                   │
          ▼                 ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐
│   SQL Server    │ │   Azure Blob    │ │      Azure AD       │
│   (Azurite)     │ │   (Azurite)     │ │      (Mock MVP)     │
└─────────────────┘ └─────────────────┘ └─────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    Revit Plugin (C#)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐    │
│  │ Revit API    │  │ WebView2     │  │ Azure Blob SDK  │    │
│  └──────────────┘  └──────────────┘  └─────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. User Stories и стейкхолдеры

### 3.1 Администратор

**US-A1: Создание ролей семейств**

> Как Администратор, я хочу создавать роли семейств с неизменяемыми системными именами (включая пакетный импорт через текст или Excel), чтобы быстро настроить систему под все семейства в шаблоне и гарантировать стабильность связей после того как роли зашиты в файлы Revit.

**Acceptance Criteria:**
- Можно создать роль с Name и Description
- Name становится read-only после создания
- Можно создать несколько ролей через текстовое поле (по имени на строку)
- Можно импортировать роли из Excel с колонками Name, Description, Category, Tags
- При импорте новые категории/теги создаются с подтверждением
- Дубликаты при создании пропускаются без ошибки

---

**US-A2: Настройка правил распознавания имён**

> Как Администратор, я хочу настраивать правила распознавания имён для каждой роли, чтобы система могла автоматически сопоставлять семейства из старых проектов с ролями по их именам файлов.

**Acceptance Criteria:**
- Операции: **Contains** и **Not Contains** — достаточно, другие не нужны
- Поддержка сложной вложенности групп с условиями AND / OR
- Пример правила: `(FB OR (Desk AND Mount)) AND Field AND Wired` — означает "содержит FB, или (содержит Desk И содержит Mount), И содержит Field, И содержит Wired"
- **UI: два режима с переключателем "Visual / Formula":**
  - Visual: древовидный конструктор с группами (AND/OR) и условиями (Contains/Not Contains)
  - Formula: текстовое поле с формульным синтаксисом, парсится в реальном времени
  - Режимы синхронизированы — изменения в одном отражаются в другом
- **Импорт из Excel:** колонки `RoleName`, `RuleFormula`. Используется тот же формульный синтаксис.
  - Синтаксис: `AND`, `OR`, `NOT` (для Not Contains), `()` для группировки, простые слова = Contains
  - При импорте: валидация формул + проверка на конфликты
- Кнопка "Test" для проверки правила на тестовом имени семейства
- Кнопка "Check Conflicts" для проверки пересечений с правилами других ролей
- Предупреждение при конфликте (одно тестовое имя подходит под правила разных ролей) — пользователь может продолжить, но должен разрешить конфликт вручную

---

### 3.2 БИМ-менеджер

---

**Важно: Два типа контента**

Система работает с двумя типами контента из Revit:

| | **Loadable Families** | **System Families** |
|---|---|---|
| **Уровень** | Семейство (Family) | Тип (Type) |
| **Файл** | .rfa | Нет файла, набор данных |
| **Редактор** | Family Editor доступен | Нет редактора |
| **Хранение в библиотеке** | .rfa файл в Azure Blob | Параметры типа (JSON) |
| **Команда в Revit** | "Add Loadable Families" | "Add System Families" |

**Роли применяются к обоим типам** — Loadable Family привязывается к роли, System Family Type тоже привязывается к роли.

**UI аналогичный для обоих типов**, но:
- Для Loadable: Tab 1 показывает список семейств
- Для System: Tab 1 показывает список типов системных семейств
- Family Editor команда работает только с Loadable (у System нет редактора)

---

**US-B1: Управление Loadable Families в шаблоне**

> Как БИМ-менеджер, я хочу видеть семейства из шаблона, выбрать те которые нужно добавить в библиотеку, и управлять их привязкой к ролям и публикацией, чтобы поддерживать актуальное состояние корпоративной библиотеки семейств.

**UI: Два таба с раздельными списками**

---

**Tab 1: "All Families"** — все семейства из шаблона (локально, чтение из Revit)

| ☐ | FamilyName | Revit Category |
|---|------------|----------------|
| ☐ | FreeAxez_Table_2024 | Furniture |
| ☐ | FreeAxez_Chair_v2 | Furniture |

**Массовые кнопки:** `[Add to Queue]` — перемещает выбранные в Tab 2

---

**Tab 2: "Library Queue"** — семейства для добавления в библиотеку (Drafts из базы)

| ☐ | FamilyName | Role (dropdown) | Status | Actions |
|---|------------|-----------------|--------|---------|
| ☐ | FreeAxez_Table_2024 | FreeAxez_Table | New | Remove from Queue |
| ☐ | FreeAxez_Chair_v2 | FreeAxez_Chair | Role Selected | Stamp |

**Массовые кнопки:**
- `[Stamp Selected]` — прошивает роль в семейство (Extensible Storage)
- `[Publish Selected]` — загружает в библиотеку (Azure Blob + база)
- `[Remove from Queue]` — удаляет из очереди

**Статусы в Queue:**
- `New` — добавлен в очередь, роль не выбрана
- `Role Selected` — роль выбрана, готов к Stamp
- `Stamped` — роль прошита в семейство, готов к Publish
- `Published` — загружен в библиотеку, перемещается в Tab 3

---

**Tab 3: "Library Status"** — семейства, опубликованные в библиотеке

| FamilyName | Role | Local Version | Library Version | Status | Actions |
|------------|------|---------------|-----------------|--------|---------|
| FreeAxez_Lamp | FreeAxez_Lamp | 2 | 2 | Up to date | Open in Library |
| FreeAxez_Shelf | FreeAxez_Shelf | 1 | 3 | Update Available | Pull Update |

**Статусы:**
- `Up to date` — версии совпадают
- `Update Available` — в библиотеке есть новая версия
- `Local Modified` — локальная версия изменена, можно опубликовать обновление

**Массовые кнопки:** `[Pull All Updates]`

---

**Таблица Drafts в базе данных:**

| Поле | Тип | Описание |
|------|-----|----------|
| Id | GUID | |
| FamilyName | string | Имя семейства из шаблона (для отображения) |
| **FamilyUniqueId** | string | `Element.UniqueId` — стабильный идентификатор в проекте |
| SelectedRoleId | GUID? | Выбранная роль (nullable) |
| TemplateId | GUID | ID шаблона/проекта |
| Status | enum | `New` / `RoleSelected` / `Stamped` / `Published` |
| CreatedAt | DateTime | Когда добавлен в очередь |
| LastSeen | DateTime | Когда последний раз видели |

**Важно:**
- Draft создаётся только при перемещении из Tab 1 в Tab 2 (Add to Queue)
- Связь по `FamilyUniqueId` — стабильна при переименовании семейства
- `FamilyName` используется только для отображения в UI
- После Publish — Draft удаляется, создаётся полноценная FamilyEntity

---

**Что записывается в Extensible Storage семейства:**

| Поле | Когда записывается | Описание |
|------|-------------------|----------|
| RoleName | Stamp | Роль семейства |
| Version | Publish | Номер версии (инкремент при каждом Publish) |
| ContentHash | Stamp | SHA256 хеш (PartAtom XML + OLE Streams) |
| PreviousHash | Publish | Хеш предыдущей версии (для отслеживания Update) |

**Важно:** IdentityGUID **НЕ используется** — он ненадёжен при копировании семейств.

---

**Логика Hash (Идентификация семейств):**

Hash вычисляется как гибридный хеш:
```
ContentHash = SHA256(NormalizedPartAtomXML + BinaryStreamsHash)
```
**Важно:** FamilyName **НЕ входит** в хеш (подробнее в 4.4.2).

**При Stamp:**
1. Вычисляем новый ContentHash
2. Проверяем по базе: есть ли семейство с таким Hash?
3. **Если найден** → предупреждение "Это дубликат семейства X. Создать новую запись?"
4. **Если не найден, но есть PreviousHash** → это Update, сравниваем с библиотекой
5. **Если не найден и нет PreviousHash** → новая запись

**Кейс копирования (с идентичным содержимым):**
- Original: `BaseUnit` → Hash=ABC → в библиотеке
- Copy: `BaseUnit_Copy` → Hash=ABC (тот же, т.к. имя не входит в хеш)
- При Stamp: Hash найден → предупреждение о дубликате, можно создать новую роль или отклонить

**Кейс редактирования:**
- Original в библиотеке: Hash=ABC
- После редактирования: Hash=XYZ
- При Stamp: PreviousHash=ABC найден в библиотеке → **Update версии**

---

**Сценарий: Publish from Family Editor**

Отдельная команда в редакторе семейств (Family Editor) для загрузки семейства в библиотеку.

**Отличия от основного сценария:**
- Открывается UI только с **Tab 2 (Library Queue)**
- Текущее семейство автоматически добавляется в очередь
- Tab 1 не нужен — работаем только с одним текущим семейством

**Логика:**
- Семейство без клейма → статус `New`, нужно выбрать роль
- Семейство с клеймом, но хеш изменился → статус `Stamped` / `Local Modified`, готов к Publish обновления
- Семейство уже опубликовано, хеш совпадает → статус `Published`, предупреждение "Already up to date"

---

**US-B2: Управление System Families в шаблоне**

> Как БИМ-менеджер, я хочу управлять типами системных семейств в библиотеке, чтобы стандартизировать параметры стен, перекрытий, труб и других системных элементов.

**Команда в Revit:** "Add System Families to Library"

**UI:** Аналогичен US-B1 (3 таба), но работаем с типами системных семейств.

---

**Классификация System Families по структуре данных:**

Системные семейства делятся на 5 групп в зависимости от сложности структуры данных:

| Группа | Структура | Категории |
|--------|-----------|-----------|
| **A** | CompoundStructure (слоистая) | Walls, Floors, Roofs, Ceilings, Foundations |
| **B** | MEP Curve Types (трубопроводные) | Pipes, Ducts, Cable Trays, Conduits |
| **C** | Railings & Stairs (иерархическая) | Railings, Stairs, Top Rails, Handrails |
| **D** | Curtain Systems (витражные) | Curtain Walls, Curtain Systems, Mullions |
| **E** | Простые (только параметры) | Levels, Grids, Ramps, Building Pads |

---

**Tab 1: "All System Types"** — типы системных семейств из проекта

| ☐ | Type Name | Category (Revit) | Group |
|---|-----------|------------------|-------|
| ☐ | Wall_External_200 | Walls | A |
| ☐ | Floor_Concrete_150 | Floors | A |
| ☐ | Pipe_Standard_DN50 | Pipes | B |

`[Add to Queue]`

---

**Tab 2: "Library Queue"** — типы для добавления в библиотеку (Drafts из базы)

| ☐ | Type Name | Role (dropdown) | Group | Status | Actions |
|---|-----------|-----------------|-------|--------|---------|
| ☐ | Wall_External_200 | FreeAxez_WallExternal | A | New | Remove from Queue |
| ☐ | Floor_Concrete_150 | FreeAxez_FloorConcrete | A | Role Selected | Stamp |

---

**Tab 3: "Library Status"** — типы, опубликованные в библиотеке

| Type Name | Role | Local Version | Library Version | Status | Actions |
|-----------|------|---------------|-----------------|--------|---------|
| Wall_Internal_100 | FreeAxez_WallInternal | 1 | 2 | Update Available | Pull Update |

---

**Структура данных по группам:**

**Группа A (CompoundStructure):**
```json
{
  "typeName": "Wall_External_200",
  "category": "Walls",
  "systemFamily": "Basic Wall",
  "parameters": {
    "Width": 200,
    "Function": "Exterior",
    "Wrapping at Inserts": "Do not wrap"
  },
  "compoundStructure": {
    "layers": [
      { "index": 0, "function": "Finish1", "materialName": "Brick, Common", "thickness": 120 },
      { "index": 1, "function": "ThermalAirLayer", "materialName": "Air", "thickness": 30 },
      { "index": 2, "function": "Structure", "materialName": "Concrete, Cast-in-Place", "thickness": 200 },
      { "index": 3, "function": "Finish2", "materialName": "Gypsum Wall Board", "thickness": 12 }
    ],
    "structuralLayerIndex": 2,
    "totalThickness": 362
  }
}
```

**Группа B (MEP):**
```json
{
  "typeName": "Standard_DN50",
  "category": "Pipes",
  "systemFamily": "Pipe Types",
  "parameters": {
    "Routing Preference": "Standard"
  },
  "routingPreferences": {
    "segments": [{ "materialName": "Carbon Steel", "scheduleType": "40" }]
  }
}
```

**Группа C (Railings) — имеет зависимости от Loadable Families:**
```json
{
  "typeName": "Railing_Glass_900",
  "category": "Railings",
  "systemFamily": "Railing",
  "parameters": { "Height": 900 },
  "railingStructure": {
    "topRailTypeName": "Circular - 50mm",
    "balusterPlacement": {
      "pattern": [{ "balusterFamilyName": "Baluster-Round", "balusterTypeName": "25mm" }]
    }
  },
  "dependencies": [
    { "familyName": "Baluster-Round", "typeName": "25mm", "inLibrary": true }
  ]
}
```

---

**Stamp для System Types:**
- Записывается в Extensible Storage **на сам ElementType** (WallType, FloorType и т.д.)
- Поля: `RoleName`, `ContentHash`, `PreviousHash`, `Version`
- **НЕ используется DataStorage** — запись на сам тип проще, данные "путешествуют" с элементом при Transfer Project Standards

**Publish:**
1. Определить группу типа (A/B/C/D/E)
2. Собрать данные по структуре группы
3. Вычислить ContentHash (SHA256 от нормализованного JSON)
4. Сохранить JSON в базу
5. Инкрементировать версию

**Pull Update:**

Если тип **СУЩЕСТВУЕТ** в проекте:
- Группа A: Создать CompoundStructure из JSON, найти материалы по имени, SetCompoundStructure()
- Группа B: Обновить параметры + RoutingPreferences
- Группа C: Проверить зависимости (Loadable Families), обновить структуру
- Группа E: Обновить параметры

Если типа **НЕТ** в проекте:
1. Найти любой существующий тип той же категории
2. Duplicate(newName)
3. Применить параметры/структуру из JSON
4. Если не найден ни один тип категории → Ошибка: "Невозможно создать тип: нет базового типа для дублирования"

---

**Маппинг материалов:**

При Publish: MaterialId → Material.Name (сохраняем имя, не Id)

При Pull Update:
1. Поиск материала по имени в проекте
2. **Если найден** → использовать его ElementId
3. **Если не найден:**
   - Показать warning: "Материал '[имя]' не найден в проекте"
   - **НЕ создавать заглушку автоматически** (создаёт мусор)
   - Предложить варианты:
     - `[Выбрать существующий]` — открыть диалог выбора материала
     - `[Создать новый]` — создать пустой материал с нужным именем
     - `[Использовать Default]` — использовать материал по умолчанию для категории
     - `[Пропустить]` — не применять CompoundStructure (продолжить без слоя)

**Серверный реестр маппинга материалов (Phase 2):**
```
Таблица MaterialMapping:
| TemplateMaterialName | ProjectMaterialName | ProjectId |
| "Brick, Common"      | "Кирпич красный"    | guid-1    |
```
Позволяет автоматически маппить материалы между шаблоном и проектами.

---

**Зависимости от Loadable Families:**

| Группа | Зависимости |
|--------|-------------|
| A (CompoundStructure) | Нет |
| B (MEP) | Фитинги — опционально |
| C (Railings/Stairs) | **Да**: балясины, стойки, профили |
| D (Curtain) | **Да**: панели (если Loadable), профили |
| E (Простые) | Нет |

**Флоу при Pull Update с зависимостями:**
```
1. Проверить: все зависимые Loadable Families есть в проекте?
2. Если нет, но есть в библиотеке → "Загрузить из библиотеки?"
3. Если нет и НЕ в библиотеке → Warning, применить с дефолтными значениями
```

---

**Pull Update при локальных изменениях:**

System Types можно модифицировать в проекте (добавить слой стене, изменить толщину). Это нормальная практика.

```
При Pull Update модифицированного типа:

Warning: "Тип 'Wall_External_200' был изменён локально.
Обновление перезапишет локальные изменения."

[Показать различия] [Обновить (перезаписать)] [Пропустить]

Показать различия:
  Библиотека (v3)          |  Локальный
  ─────────────────────────|──────────────────
  Brick       120mm        |  Brick       120mm
  Air          30mm        |  Air          30mm
  -                        |  Insulation   50mm  ← добавлено локально
  Concrete    200mm        |  Concrete    200mm
  Gypsum       12mm        |  Gypsum       12mm
  Total:      362mm        |  Total:      412mm
```

---

**Фазовый план реализации:**

| Фаза | Группы | Категории |
|------|--------|-----------|
| **MVP** | A, E | Walls, Floors, Levels, Grids |
| **Phase 2** | A, B | Roofs, Ceilings, Foundations, Pipes, Ducts |
| **Phase 3** | B, C, D | Cable Trays, Conduits, Railings, Stairs, Curtain Walls |

**Spikes / Research (перед Phase 1):**

| Spike | Цель | Приоритет |
|-------|------|-----------|
| PartAtom детерминизм | Экспортировать RFA 10 раз → сравнить XML → подтвердить стабильность хеша | Высокий |
| OLE Streams чтение | Прочитать geometry streams из RFA → хешировать | Высокий |
| ES + Transfer Project Standards | Создать WallType с ES → Transfer в другой проект → проверить ES | Средний |
| ES upgrade Revit | Открыть проект 2024 в 2025 → проверить ES | Средний |

---

**Особые случаи стен (WallType.Kind):**

| Kind | Описание | CompoundStructure | Фаза |
|------|----------|-------------------|------|
| `Basic` | Обычная стена со слоями | Да | MVP |
| `Curtain` | Витражная стена | Нет (сетка + панели) | Phase 3 |
| `Stacked` | Составная стена (две базовых) | Нет (ссылки на WallType) | Phase 3 |

**Stacked Wall JSON:**
```json
{
  "typeName": "Stacked_External",
  "kind": "Stacked",
  "stackedLayers": [
    { "wallTypeName": "Wall_Lower_Concrete", "height": 1200 },
    { "wallTypeName": "Wall_Upper_Brick", "height": 0 }
  ]
}
```

**Зависимость:** при Pull Update нужны оба дочерних WallType в проекте.

---

### 3.3 Проектировщик

**US-D1: Просмотр библиотеки**

> Как Проектировщик, я хочу просматривать корпоративную библиотеку семейств внутри Revit, чтобы найти и загрузить нужные семейства в проект.

**Команда в Revit:** "Open Family Library"

**UI:** Открывается в WebView2 внутри Revit

**Виды отображения (переключатель):**

1. **Карточки** — семейства в виде карточек с превью, название, роль, категория
2. **Таблица** — компактный список с колонками: Name, Role, Category, Tags, Version

**Фильтры сверху:**
- Поиск по имени (free text)
- Фильтр по категории (dropdown)
- Фильтр по тегам (multi-select)
- Фильтр по типу (Loadable / System)

---

**Страница семейства (при выборе):**

Отдельная страница с детальной информацией о семействе.

**Секции:**
- Превью семейства
- Описание, роль, категория, теги
- **Таблица версий** — история всех версий с датами
- **Таблица типов** — для выбранной версии (если есть Type Catalog)
- **Матрица параметров** — сравнение параметров между типами

**Важно:**
- **Все версии сохраняются в библиотеке** — история версий доступна для просмотра
- По каждой версии можно посмотреть типы и их параметры
- Картинка/превью для каждого типа (если доступно)

**Действия:**
- `[Load to Project]` — загрузить выбранную версию/типы в проект
- `[Back to Library]` — вернуться к списку

---

**US-D2: Загрузка семейства в проект**

> Как Проектировщик, я хочу загрузить семейство из библиотеки в текущий проект, чтобы использовать его в модели.

**Логика скачивания из библиотеки:**

1. Получить метаданные версии (включая `OriginalFileName`, `OriginalCatalogName`)
2. Скачать `family.rfa` из Blob
3. Скачать `catalog.txt` из Blob (если есть)
4. Переименовать файлы в оригинальные имена:
   - `family.rfa` → `{OriginalFileName}` (например, `FreeAxez_Table_2024.rfa`)
   - `catalog.txt` → `{OriginalCatalogName}` (например, `FreeAxez_Table_2024.txt`)
5. Сохранить во временную папку
6. Загрузить в Revit

**Результат:** пользователь получает файлы с оригинальными именами семейства.

---

**Логика загрузки:**

| Тип семейства | Действие |
|---------------|----------|
| С TXT файлом | Открывается диалог выбора типов → загружаются выбранные |
| Без TXT | Загружается сразу (все встроенные типы) |

**Статусы семейств в проекте (показываются в библиотеке):**

| Статус | Описание | Действие |
|--------|----------|----------|
| Not in Project | Семейства нет в проекте | Load |
| Up to date | Последняя версия | Недоступно |
| Update Available | В библиотеке есть новая версия | Update |
| Legacy (по правилам) | Найдено по имени через правила распознавания | Update |

**Важно:**
- **Update** — только до последней версии
- **Старые версии** — можно скачать только на странице деталей семейства (для особых случаев)

---

**US-B4: Type Catalogs (TXT файлы с типоразмерами)**

> Как БИМ-менеджер, я хочу прикреплять TXT файлы с каталогами типоразмеров к Loadable Families, чтобы семейства с большим количеством типов хранились эффективно и загружались точечно.

**Когда нужен TXT:**
- Некоторые семейства не имеют встроенных типов, а используют внешний Type Catalog
- Система должна предупреждать/подсказывать, если семейству нужен TXT файл

---

**Publish с TXT:**

При публикации семейства в библиотеку:
- Пользователь **явно выбирает** TXT файл для прикрепления
- TXT хранится рядом с RFA в Azure Blob (системное имя `catalog.txt`)
- Оригинальное имя TXT сохраняется в `OriginalCatalogName`
- Возможность обновить TXT файл для уже опубликованного семейства

**Версионирование:**
- Обновление RFA → новая версия
- Обновление TXT → новая версия
- Хеш вычисляется из **RFA + TXT** вместе

---

**Загрузка в проект (для Проектировщика):**

**Важно:** Revit API **не показывает** нативный диалог выбора типов при загрузке через `LoadFamily()`. Плагин должен сам парсить TXT и вызывать `LoadFamilySymbol()` для каждого типа.

**Алгоритм загрузки:**

```
1. Скачать RFA + TXT во временную папку
2. Переименовать в оригинальные имена (OriginalFileName + OriginalCatalogName)
   - TXT должен иметь то же имя, что и RFA (без расширения)
   - Например: FreeAxez_Table_2024.rfa + FreeAxez_Table_2024.txt
3. Парсить TXT файл:
   - Заголовок: ИмяПараметра##ТипДанных##Единицы
   - Строки: ИмяТипа;значение1;значение2;...
4. Показать UI выбора типов (список всех типов из TXT)
5. Для каждого выбранного типа:
   - Вызвать LoadFamilySymbol(rfaPath, typeName, IFamilyLoadOptions)
   - Revit загрузит тип из TXT
6. Удалить временные файлы
```

**Пример кода:**
```csharp
// Парсинг TXT
var catalogTypes = ParseTypeCatalog(txtPath);

// UI выбора
var selectedTypes = ShowTypeSelectionDialog(catalogTypes);

// Загрузка выбранных типов
foreach (var typeName in selectedTypes)
{
    doc.LoadFamilySymbol(rfaPath, typeName, loadOptions, out _);
}
```

**Важно:** В самом проекте .rvt TXT файлы не хранятся. Данные типов загружаются в память и применяются к семейству.

---

### 3.4 Общий модуль: Сканер (для всех ролей)

**US-B3: Update from Library (Сканер для обновления в проекте)**

> Как пользователь (любая роль), я хочу проверить семейства в проекте на актуальность и обновить их до последних версий из библиотеки.

**Команда в Revit:** "Update Families from Library"

**Доступно для:** всех ролей (Проектировщик, БИМ-менеджер, Администратор)

**UI:** Одна страница со сканером и таблицей результатов

---

**Таблица результатов сканирования:**

| ☐ | Family Name | Category | Current Role | Status | Actions |
|---|-------------|----------|--------------|--------|---------|
| ☐ | FreeAxez_Table | Furniture | FreeAxez_Table | 🟢 Up to date | — |
| ☐ | Old_Table_v1 | Furniture | FreeAxez_Table | 🟡 Update Available | Update |
| ☐ | Legacy_Chair | Furniture | *(auto: FreeAxez_Chair)* | 🔵 Legacy Match | Update |
| ☐ | Unknown_Item | Furniture | — | ⚪ Unmatched | — |

**Фильтры над таблицей:**
- Status: All / Update Available / Legacy Match / Unmatched / Up to date
- Category (Revit)

**Статусы:**
- 🟢 **Up to date** — семейство актуально, обновление не требуется
- 🟡 **Update Available** — в библиотеке есть новая версия
- 🔵 **Legacy Match** — без клейма, но найдено по правилам распознавания
- ⚪ **Unmatched** — без клейма, не найдено по правилам

**Массовые кнопки:**
- `[Update Selected]` — обновить выбранные до последней версии
- `[Update All Available]` — обновить все с статусом Update Available

---

**Важно: Разделение страниц**

| | **Add to Library** (US-B1) | **Update from Library** (US-B3) |
|---|---|---|
| **Кто** | БИМ-менеджер, Администратор | Все роли |
| **Контекст** | Шаблон, редактор семейств | Любой проект |
| **Действия** | Stamp, Publish | Update, Pull |
| **UI** | 3 таба (All / Queue / Status) | Таблица сканера |

**Общий модуль:** логика сканирования (проверка клейм, применение правил распознавания по имени) используется в обоих сценариях

---

## 4. Функциональные требования

### 4.1 Модуль 1: Управление ролями семейств (Конфигурация)

#### 4.1.1 Сущности

**Роль семейства (FamilyRole)**

| Свойство | Тип | Описание | Ограничения |
|----------|-----|----------|-------------|
| Name | string | Системное имя роли (например, `FreeAxez_BaseUnit`) | **Read-only после создания** |
| Description | string? | Описание роли (опционально) | Редактируется |
| Type | enum | `Loadable` или `System` | **Read-only после создания** |
| Category | Category? | Категория роли (опционально) | Редактируется |
| Tags | List<Tag> | Список тегов роли | Редактируется |

**Важно:** Роли разделены по типу:
- `Loadable` — применяются только к Loadable Families (.rfa)
- `System` — применяются только к System Family Types
- Нельзя смешивать — Loadable семейство нельзя привязать к System роли

**Категория (Category)**

| Свойство | Тип | Описание |
|----------|-----|----------|
| Name | string | Имя категории (например, "Тумбы", "Столы") |
| Description | string? | Описание (опционально) |
| SortOrder | int | Порядковый номер для сортировки |

**Тег (Tag)**

| Свойство | Тип | Описание |
|----------|-----|----------|
| Name | string | Имя тега (например, "Для кухни", "Новый") |
| Color | string | Цвет для визуального выделения в UI |

#### 4.1.2 Правила поведения

**Роли:**
- **Создание**:
  - Одиночное — через стандартную форму
  - Пакетное (быстрое) — текстовое поле, вставляем список имён (по одному на строку), создаются с пустыми Description/Category/Tags
  - Пакетное (Excel) — импорт Excel-файла с данными
    - Колонки: `Name`, `Type`, `Description`, `Category`, `Tags`
    - Type: `Loadable` или `System`
    - Tags — через разделитель (запятая)
    - Category — ищется по имени
    - Если поле не заполнено — оставляем пустым
    - Если категория/тег не найдены в системе — предупреждение с вопросом "Создать новые?"
- **UI управления ролями:**
  - Две вкладки: "Loadable Roles" и "System Roles"
  - При создании роли — выбирается Type (Loadable/System)
  - После создания Type нельзя изменить
- **Проверка дубликатов**: При создании/импорте — если роль уже существует, пропускаем
- **Редактирование**: Name и Type изменить нельзя, остальные свойства — можно
- **Удаление**: Разрешено только если к роли не привязано ни одного семейства

**Категории и теги:**
- **Удаление**: Можно удалить в любой момент. При удалении — связи обнуляются у всех ролей (категория → null, тег удаляется из списка)

#### 4.1.3 "Как работает"

**Идентификация семейств:**
1. Каждое семейство (Loadable) или тип (System) привязывается к ровно одной роли
2. Роль записывается в Extensible Storage при Stamp
3. Роль остаётся неизменной даже при переименовании семейства
4. При потере ES-данных → Legacy Recognition по правилам имени

**Жизненный цикл:**
```
Семейство без роли → Stamp (выбор роли) → ES записан →
Publish → Библиотека (версия 1) →
Редактирование → Stamp → Publish → Библиотека (версия 2) → ...
```

**Связи:**
- Роль → Категория (0..1): опциональная группировка
- Роль → Теги (0..*): опциональные метки
- Роль → Семейства (0..*): одно семейство = одна роль
- Роль → Правило распознавания (0..1): опционально

**Проверка при создании роли:**
1. Валидация Name (не пустое, уникальное)
2. Валидация Type (Loadable или System)
3. Если есть Category — проверка существования
4. Если есть Tags — проверка существования или создание

#### 4.1.4 "Как НЕ работает" (Explicit Constraints)

**Запрещено:**
- Name роли запрещено редактировать после создания
- Type роли запрещено менять после создания
- Роль нельзя удалить, если к ней привязаны семейства
- Нельзя привязать Loadable семейство к System роли
- Нельзя привязать System Type к Loadable роли
- Нельзя создать роль с пустым Name
- Нельзя создать роль с дублирующимся Name

**Не поддерживается:**
- In-Place Families игнорируются системой
- Семейства без клейма не публикуются (требуется Stamp)
- Семейства с одинаковыми именами в разных категориях идентифицируются по паре (FamilyName, Category)

**Ограничения:**
- Drafts связываются с шаблоном по FamilyUniqueId (Element.UniqueId) — связь стабильна при переименовании семейства
- Правила распознавания не могут конфликтовать (одно имя = максимум одна роль)
- Stamp в Worksharing требует ownership на элемент

---

### 4.2 Модуль 2: Движок распознавания (Legacy Recognition Engine)

Модуль для сопоставления семейств из старых проектов с ролями по правилам анализа имён.

#### 4.2.1 Операции распознавания

| Операция | Описание | Пример |
|----------|----------|--------|
| Contains | Имя содержит подстроку | `Contains:Table` → "Kitchen_Table_v2" ✅ |
| Not Contains | Имя НЕ содержит подстроку | `NOT Hidden` → "Table_Visible" ✅ |
| AND | Все условия истинны | `Table AND Wood` |
| OR | Хотя бы одно истинно | `Table OR Desk` |

#### 4.2.2 Структура правила

Правило — это дерево с узлами двух типов:
- **Группа** — контейнер с логикой AND/OR
- **Условие** — Contains / Not Contains с параметром (подстрока)

**Пример правила:**
```
(FB OR (Desk AND Mount)) AND Field AND Wired AND NOT Hidden
```

**Парсится в дерево:**
```
AND
├── OR
│   ├── Contains: "FB"
│   └── AND
│       ├── Contains: "Desk"
│       └── Contains: "Mount"
├── Contains: "Field"
├── Contains: "Wired"
└── NOT Contains: "Hidden"
```

#### 4.2.3 Синтаксис формул (для Formula mode и Excel)

| Элемент | Синтаксис | Пример |
|---------|-----------|--------|
| Contains | слово без кавычек | `Table` |
| Not Contains | `NOT слово` | `NOT Hidden` |
| AND | `AND` или `&` | `Table AND Wood` |
| OR | `OR` или `\|` | `Table OR Desk` |
| Группировка | `()` | `(A OR B) AND C` |

#### 4.2.4 UI редактора правил

**Два режима с переключателем:**
1. **Visual** — древовидный конструктор с drag-and-drop
2. **Formula** — текстовое поле с формулой

**Функции:**
- `Test` — проверить правило на тестовом имени семейства
- `Check Conflicts` — проверить пересечения с правилами других ролей

#### 4.2.5 Проверка конфликтов

**Конфликт:** одно тестовое имя подходит под правила двух разных ролей.

**Поведение:**
- **НЕ блокировать** сохранение правила при конфликте
- Показать **warning**: "Имя 'Table_Wood_v2' подходит также под роль 'FreeAxez_Table'. Возможен конфликт при сканировании."
- Пользователь может сохранить правило с warning

**Реальная проверка конфликтов — при сканировании:**
```
При сканировании проекта:
  Если имя семейства подходит под правила 2+ ролей:
    - Показать пользователю выбор: "Какую роль назначить?"
    - Запомнить выбор для этого проекта
    - Предложить Stamp с выбранной ролью
```

**База "известных имён":**
- При каждом сканировании — сохранять встреченные имена семейств
- При тестировании правил — проверять по базе известных имён
- Warning если правило покрывает < 1% известных имён (слишком широкое)

#### 4.2.6 Импорт правил из Excel

| Колонка | Описание |
|---------|----------|
| RoleName | Имя роли (ищется по Name) |
| RuleFormula | Формула правила |

**При импорте:**
- Валидация синтаксиса формул
- Проверка конфликтов для всех правил
- Показать ошибки перед применением

---

### 4.3 Модуль 3: Клеймение и Идентификация (Stamping)

Модуль для записи метаданных в семейства через Extensible Storage.

#### 4.3.1 Структура клейма (Extensible Storage)

| Поле | Тип | Описание |
|------|-----|----------|
| RoleName | string | Имя роли семейства |
| Version | int | Номер версии (заполняется при Publish) |
| ContentHash | string | SHA256 хеш (Нормализованный PartAtom XML) |
| PreviousHash | string? | Хеш предыдущей версии (для отслеживания Update) |

**Важно:** IdentityGUID **НЕ используется** — ненадёжен при копировании семейств (копируется при Save As).

#### 4.3.2 Extensible Storage: Архитектура и риски

**Архитектура схемы:**
- Использовать **один стабильный GUID** для схемы на весь жизненный цикл плагина
- **Никогда** не менять GUID — только добавлять новые поля
- При breaking changes — создавать **новую схему с новым GUID**, читать из старой и писать в новую

**Миграция при обновлении плагина:**
```
При открытии проекта:
1. Попытаться прочитать Schema v2 (текущая)
2. Если не найдена → попытаться прочитать Schema v1 (старая)
3. Если найдена v1 → мигрировать данные в v2
4. Если не найдена ни одна → семейство без клейма (Legacy)
```

**Риски Worksharing:**
- Запись ES = модификация элемента → требуется ownership
- При Stamp — Revit попытается **borrow** Family element
- Если другой пользователь заимствовал — ошибка "Element is being edited"

**Обработка Worksharing:**
- Перед записью ES проверять `WorksharingUtils.GetCheckoutStatus(doc, elementId)`
- Если элемент занят — показать warning, предложить повторить позже
- **Рекомендация:** выполнять Stamp/Publish из non-workshared шаблона

**Fallback при потере ES-данных (upgrade Revit, schema conflicts):**

При потере ES-данных срабатывает каскадный механизм восстановления:

```
Семейство без ES-клейма:
  1. Проверить серверный маппинг: FamilyName → RoleName
     - Если найден → восстановить клеймо (Stamp с найденной ролью)
     - Если не найден → перейти к п.2

  2. Применить Legacy Recognition по правилам имени
     - Если найдено совпадение → Stamp с авто-ролью
     - Если не найдено → Unmatched (требуется ручной выбор)

  3. Показать пользователю:
     "Семейство 'FreeAxez_Table' потеряло метаданные библиотеки.
      Восстановлено по имени. Роль: FreeAxez_Table.
      [Подтвердить] [Выбрать другую роль]"
```

**Серверный маппинг для восстановления:**

Таблица `FamilyNameMapping`:
| Поле | Описание |
|------|----------|
| FamilyName | Имя семейства (оригинальное) |
| RoleName | Привязанная роль |
| ProjectId | ID проекта/шаблона |
| LastSeenAt | Когда последний раз видели |

При каждом сканировании — обновлять маппинг. При потере ES — использовать для восстановления.

#### 4.3.3 Stamp: Онлайн vs Офлайн

**Stamp = локальная операция**, не требует подключения к серверу.

| Этап | Что делает | Онлайн? | Результат |
|------|-----------|---------|-----------|
| **Stamp (локальный)** | Записывает RoleName и ContentHash в ES семейства | Нет | ES записано |
| **Validate (серверный)** | Проверяет дубликаты, конфликты хешей | Да (опционально) | Warning/Confirmation |
| **Publish** | Загрузка в библиотеку | Да | Запись в БД + Blob |

**Флоу:**
```
Пользователь выбирает роль → нажимает [Stamp]

1. [ЛОКАЛЬНО] Вычисляем ContentHash (PartAtom XML)
2. [ЛОКАЛЬНО] Записываем в ES: RoleName, ContentHash, PreviousHash (если есть)
3. [ЛОКАЛЬНО] Статус → Stamped
4. [ОПЦИОНАЛЬНО, ЕСЛИ ЕСТЬ СЕТЬ] Validate:
   - Отправляем ContentHash на сервер
   - Сервер проверяет: есть ли дубликат?
   - Если да → Warning (не блокирующий)
   - Если нет → OK

5. [PUBLISH — требует сеть]
   - Полная проверка на сервере
   - Загрузка RFA + TXT
   - Создание версии
```

#### 4.3.4 Lifecycle полей ES

| Поле | Когда записывается | Кем обновляется |
|------|-------------------|-----------------|
| `RoleName` | Stamp | Только при пере-Stamp (смена роли) |
| `ContentHash` | Stamp | Каждый Stamp (перевычисляется) |
| `PreviousHash` | Stamp | = старый ContentHash перед перезаписью |
| `Version` | Publish | Сервер при успешной публикации |

**Пример lifecycle:**
```
1. Stamp первый раз:
   ES: { RoleName: "Table", ContentHash: "AAA", PreviousHash: null, Version: null }

2. Publish:
   ES: { RoleName: "Table", ContentHash: "AAA", PreviousHash: null, Version: 1 }
   DB: { Role: "Table", Hash: "AAA", Version: 1 }

3. Пользователь редактирует семейство, Stamp:
   ES: { RoleName: "Table", ContentHash: "BBB", PreviousHash: "AAA", Version: 1 }

4. Publish:
   ES: { RoleName: "Table", ContentHash: "BBB", PreviousHash: "AAA", Version: 2 }
   DB: { Role: "Table", Hash: "BBB", Version: 2, PreviousHash: "AAA" }
```

#### 4.3.5 Обработка копирования семейства

**Правило: одна роль → одно семейство в библиотеке.** Несколько семейств с одной ролью в одном проекте — допустимо, но в библиотеку публикуется только одно.

**Сценарий:** БИМ-менеджер копирует `FreeAxez_Table` → `FreeAxez_Table_Copy`. Оба содержат одинаковый ES-клеймо.

**Флоу при Add to Queue для копии:**
```
1. Оба семейства имеют ES с RoleName = "FreeAxez_Table"
2. ContentHash у копии = ContentHash оригинала (содержимое идентично)

При попытке Add to Queue для FreeAxez_Table_Copy:
  - Система читает ES → видит RoleName = "FreeAxez_Table"
  - Система сравнивает ContentHash → совпадает с опубликованным
  - Warning: "Это семейство является копией 'FreeAxez_Table' (та же роль, тот же контент)."
    [Пропустить] [Назначить новую роль] [Заменить оригинал]

Если пользователь изменил копию (ContentHash отличается):
  - Warning: "Семейство имеет роль 'FreeAxez_Table', но контент отличается."
    [Опубликовать как обновление] [Назначить новую роль]
```

#### 4.3.6 "Как НЕ работает"

- Stamp **не записывает** Version (версия только при Publish)
- Stamp **не создаёт** запись в базе данных (только локально в семействе)
- Stamp **не перезаписывает** клеймо без подтверждения (если уже есть)
- Stamp **не блокируется** при отсутствии сети (работает офлайн)
- Stamp **не требует** ownership в Worksharing (но показываем warning)

---

### 4.4 Модуль 4: Версионирование (Deep Fingerprinting)

Модуль для контроля изменений и управления версиями семейств.

#### 4.4.1 Стратегия хеширования

**Проблема:** В Revit API нет стандартного детерминированного способа сериализовать геометрию семейства.

**Решение: Гибридный хеш (PartAtom XML + OLE Streams)**

```
ContentHash = SHA256(
    NormalizedPartAtomXML    // параметры, типы, категория
    + BinaryStreamsHash      // геометрия из OLE Structured Storage
)
```

**Компонент 1: PartAtom XML**
- Revit API метод `Application.ExtractPartAtomFromFamilyFile(rfaPath, xmlPath)` экспортирует XML
- Содержит: имя, категорию, параметры, типы, единицы измерения
- **Не содержит** геометрию напрямую, но содержит параметры, управляющие геометрией

**Компонент 2: OLE Structured Storage Streams**
- Прочитать RFA как OLE Structured Storage (Compound File Binary Format)
- Извлечь потоки данных (streams), исключив metadata-потоки с timestamps:
  - `PrimaryLinePattern` и подобные — игнорировать
  - Geometry streams — включить
- Хешировать конкатенацию content streams

**Нормализация XML перед хешированием:**
- Удалить элементы `<entry><updated>` timestamps
- Отсортировать элементы по имени (параметры, типы)
- Привести числа к единому формату (без trailing zeros)
- Trim пробелов, унификация line endings (CRLF)

**Empirical validation (Spike Phase 1):**
- Экспортировать один RFA файл 10 раз подряд без изменений
- Сравнить XML побайтово после нормализации
- Убедиться в детерминированности хеша

**Fallback:** Кнопка "Force Publish" для случаев, когда пользователь знает об изменениях, но хеш не изменился (edge case).

#### 4.4.2 Важно: Имя НЕ входит в хеш

**Из оригинального ТЗ:** `SHA256(FamilyName + GeometryData + ParametersData)` — **ИСПРАВЛЕНО**

**Новое правило:** FamilyName **НЕ входит** в ContentHash.

**Причина:** Переименование семейства не должно создавать новую версию.

**Как различать копии:**
- Два семейства с одинаковым содержимым, но разными именами → одинаковый хеш (это нормально)
- Различие — через RoleName в ES + FamilyName как display name

#### 4.4.3 Вычисление версии

**Триггеры новой версии:**
- Изменение параметров/типов в RFA → PartAtom XML меняется → Hash меняется
- Добавление/удаление/переименование вложенного семейства → PartAtom XML меняется
- Изменение TXT файла (Type Catalog) → TxtHash меняется
- Изменение геометрии (редкий случай) → **Force Publish** вручную

**Не триггеры:**
- Переименование семейства → Hash тот же
- Пересохранение файла без изменений → Hash тот же
- Изменение даты файла в Windows → игнорируется

#### 4.4.4 Составной Hash (для семейств с TXT)

Если семейство имеет Type Catalog:
```
TotalHash = SHA256(RfaHash + TxtHash)
```

**Нормализация TXT перед хешированием:**
- Удаление пустых строк
- Trim пробелов
- Унификация переносов строк (CRLF)
- Нормализация разделителя (всегда `;`)

#### 4.4.5 Хеширование System Types

Для системных семейств (WallType, FloorType и т.д.):
```
ContentHash = SHA256(NormalizedJSON)

Нормализация JSON:
- Сортировка ключей по алфавиту
- Числа без trailing zeros
- Материалы — по имени (не по ElementId)
- Зависимые семейства — по имени (не по ElementId)
- Удаление runtime-специфичных полей (Id, ElementId)
```

#### 4.4.6 Хранение версий

**Все версии сохраняются** в Azure Blob:
- `families/{roleName}/v1/family.rfa` — системное имя файла
- `families/{roleName}/v1/catalog.txt` — системное имя TXT (если есть)

**В базе данных (таблица FamilyVersion):**

| Поле | Тип | Описание |
|------|-----|----------|
| Id | GUID | |
| FamilyId | GUID | ID семейства |
| Version | int | Номер версии |
| Hash | string | SHA256 хеш версии |
| PreviousHash | string? | Хеш предыдущей версии |
| BlobPath | string | Путь к RFA в Blob |
| CatalogBlobPath | string? | Путь к TXT в Blob (если есть) |
| **OriginalFileName** | string | Оригинальное имя RFA (например, `FreeAxez_Table_2024.rfa`) |
| **OriginalCatalogName** | string? | Оригинальное имя TXT (например, `FreeAxez_Table_2024.txt`) |
| PublishedAt | DateTime | Дата публикации |
| PublishedBy | string | Кто опубликовал (email) |
| **CommitMessage** | string? | Опциональное описание изменений (например, "Добавлен новый тип Type_D") |
| SnapshotJSON | string | JSON-snapshot состояния (параметры, типы) |

**Важно:**
- `OriginalFileName` и `OriginalCatalogName` используются при скачивании для переименования файлов в оригинальные имена
- `CommitMessage` — опциональное поле, заполняется пользователем при Publish, отображается в истории версий

#### 4.4.7 Сравнение версий

**При сканировании проекта:**
1. Плагин читает Hash из Extensible Storage
2. Запрашивает последнюю версию из базы по RoleName
3. Сравнивает Hash:
   - Совпадает → 🟢 Up to date
   - Отличается → 🟡 Update Available

**Многопользовательская работа:**
- При одновременном Publish — оптимистичная блокировка через версию
- `UPDATE ... WHERE Version = @expectedVersion` — если кто-то уже обновил, ошибка → retry

---

### 4.5 Модуль 5: Type Catalog (Каталог типоразмеров)

Модуль для работы с TXT-файлами типоразмеров (Type Catalog) при загрузке семейств.

#### 4.5.1 Формат TXT файла

**Имя файла:** `{FamilyName}.txt` — должно совпадать с именем RFA файла (без расширения).

**Формат:**
```
TypeName,Parameter1##type##units,Parameter2##type##units,...
Type_A,value1,value2,...
Type_B,value1,value2,...
```

**Синтаксис CSV:**
- Разделитель: `,` (comma)
- Поддержка quotes для значений с запятыми: `"Value, with comma"`
- Первая строка = заголовки
- Остальные строки = данные типов

**Заголовки параметров:**
- Формат: `ParameterName##DataType##Units`
- `ParameterName` — имя параметра в семействе
- `DataType` — тип данных (LENGTH, INTEGER, TEXT, etc.)
- `Units` — единицы измерения (millimeters, meters, etc.)

**Пример:**
```
TypeName,Width##LENGTH##millimeters,Height##LENGTH##millimeters,Material##TEXT##
Table_600,600,750,Oak
Table_800,800,750,Pine
Desk_1200,1200,750,"Metal, Steel"
```

#### 4.5.2 Модели данных

**FamilyTypeModel:**
| Поле | Тип | Описание |
|------|-----|----------|
| TypeName | string | Имя типа (первая колонка) |
| Parameters | List | Список параметров типа |

**ParameterValueModel:**
| Поле | Тип | Описание |
|------|-----|----------|
| ParameterName | string | Имя параметра (без ## суффиксов) |
| Value | object | Значение (double, int, или string) |
| Units | string | Единицы измерения |
| RawValue | string | Исходное строковое значение |
| DisplayValue | string | Форматированное для UI |

**ParameterFilterModel (для UI фильтров):**
| Поле | Тип | Описание |
|------|-----|----------|
| ParameterName | string | Имя параметра для фильтрации |
| DisplayName | string | Отображаемое имя |
| UniqueParameterValues | ObservableCollection\<string\> | Все уникальные значения |
| ParameterItems | ObservableCollection\<ParameterItemModel\> | Элементы для выбора |
| IsAnyItemSelected | bool | Есть ли выбранные элементы |

**ParameterItemModel:**
| Поле | Тип | Описание |
|------|-----|----------|
| ParameterValue | string | Значение параметра |
| IsSelected | bool | Выбран ли элемент в фильтре |

#### 4.5.3 Парсинг TXT (TypesFileParser)

**Алгоритм:**
```
1. Прочитать все строки файла
2. ParseCsvLine(lines[0]) → headers
3. Для каждой data-строки:
   - ParseCsvLine() → values
   - Проверка: values.Count == headers.Count (skip if not)
   - Создать FamilyTypeModel:
     - TypeName = values[0]
     - Parameters = values[1..n] с парсингом типов
4. Вернуть List<FamilyTypeModel>
```

**Парсинг CSV с quotes:**
```
ParseCsvLine(line):
  result = []
  current = ""
  inQuotes = false
  for each char in line:
    if char == '"': inQuotes = !inQuotes
    else if char == ',' && !inQuotes:
      result.Add(current.Trim())
      current = ""
    else: current += char
  result.Add(current.Trim())
  return result
```

**Автоопределение типа значения:**
1. Попробовать `double.TryParse(CultureInfo.InvariantCulture)`
2. Иначе `int.TryParse()`
3. Иначе оставить как string

#### 4.5.4 UI выбора типов (TypeSelectionWindow)

**Триггер:** Если семейство имеет TXT файл → показать окно выбора типов.

**Макет окна:**
```
┌─────────────────────────────────────────────────────────────────────┐
│ Select types to load. Use Ctrl and Shift to select multiple types.  │
├─────────────────────────────────────────────────────────────────────┤
│ [Search by name or parameter...    ] Selected: 3                    │
├─────────────────────────────────────────────────────────────────────┤
│ [Filter: Width ▼] [Filter: Material ▼] [Filter: Height ▼]          │
├─────────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────────────────────────────┐ │
│ │ Type        │ Width │ Height │ Material                         │ │
│ ├─────────────┼───────┼────────┼──────────────────────────────────│ │
│ │ ☑ Table_600 │ 600   │ 750    │ Oak                              │ │
│ │ ☐ Table_800 │ 800   │ 750    │ Pine                             │ │
│ │ ☑ Desk_1200 │ 1200  │ 750    │ Metal, Steel                     │ │
│ └─────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────┤
│ [Reset filters]                           [OK]      [Cancel]        │
└─────────────────────────────────────────────────────────────────────┘
```

**Функциональность:**

| Функция | Описание |
|---------|----------|
| **Динамические колонки** | Колонки создаются из заголовков TXT (кроме TypeName) |
| **Поиск** | Фильтрация по TypeName и значениям параметров (case-insensitive) |
| **Фильтры по параметрам** | ComboBox для каждого параметра с уникальными значениями |
| **Множественный выбор** | Ctrl/Shift для выбора нескольких типов |
| **Счётчик выбранных** | "Selected: N" отображается в реальном времени |

**Скрытие параметров (не показывать в UI):**
- `Comment` (любой параметр с "Comment" в имени)
- `GPM`
- `Legacy Part Number`

**Адаптивный размер окна:**
- 3 или меньше параметров → ширина 640px
- Больше 3 параметров → ширина = `paramCount * 180` (max 1600px)
- Высота: 440px (до 10 типов) или 800px (более 10 типов)

#### 4.5.5 Загрузка в проект (для Проектировщика)

**Процесс:**
```
1. Скачать RFA + TXT во временную папку
2. Если TXT существует:
   a. ParseTypesFile(txtPath) → List<FamilyTypeModel>
   b. Показать TypeSelectionWindow
   c. Получить выбранные типы
   d. Если пользователь отменил → abort
3. Загрузить семейство:
   a. Document.LoadFamily(rfaPath, options, out Family)
   b. Собрать все FamilySymbol из загруженного Family
   c. Удалить невыбранные типы (Document.Delete)
4. Очистить временную папку
5. Показать сообщение: "Family 'X' loaded with N selected type(s)."
```

**Важно:**
- Используется `LoadFamily()`, НЕ `LoadFamilySymbol()` — Revit API не поддерживает выборочную загрузку через Type Catalog
- TXT не сохраняется в проекте — данные типов загружаются в память при загрузке семейства
- Предварительно существующие типы в проекте НЕ удаляются (защита от потери данных)

#### 4.5.6 Слияние данных RFA + TXT

**Приоритет TXT:** если TXT файл существует при Publish, встроенные типы RFA **скрываются** в библиотеке.

**Метаданные для библиотеки:**
| Источник | Данные |
|----------|--------|
| RFA | Превью, категория, список встроенных типов |
| TXT | Матрица типов с параметрами |

**При отсутствии TXT:** используются встроенные типы RFA.

#### 4.5.7 Обновление семейства в проекте

**При Pull Update:**
```
1. Скачать новую версию RFA + TXT
2. Показать TypeSelectionWindow (если есть TXT)
3. Использовать IFamilyLoadOptions для перехвата диалога
4. Автоматический ответ "Да" на "Перезаписать значения параметров?"
5. Новые параметры из TXT применяются к существующим элементам
```

**Замена старого семейства (Replacement):**
Если загружаемое семейство заменяет старое (другое имя файла):
1. Найти все FamilyInstance с Symbol.Family.Name = oldFamilyName
2. Для каждого: найти новый тип с matching name
3. ChangeTypeId() + перенести значения параметров
4. Удалить старое семейство (Document.Delete)

**Параметры, НЕ переносимые при замене:**
- Version
- Product Name
- Description

---

### 4.6 Модуль 6: Сканер проектов и Синхронизация (Project Scanner)

Модуль для анализа семейств в проекте и их синхронизации с библиотекой.

#### 4.6.1 Две страницы сканера

| Страница | Назначение | Доступ |
|----------|------------|--------|
| **Add to Library** | Загрузка семейств из шаблона в библиотеку | БИМ-менеджер, Администратор |
| **Update from Library** | Обновление семейств в проекте из библиотеки | Все роли |

#### 4.6.2 Алгоритм сканирования

```
Для каждого семейства в проекте:
  1. Проверить Extensible Storage
     - Есть RoleName + ContentHash? → Stamped
     - Нет? → Legacy check

  2. Если Stamped:
     - Запросить версию из библиотеки по RoleName
     - Сравнить Hash
     - Hash совпадает → Up to date
     - Hash отличается → Update Available

  3. Если Legacy:
     - Применить правила распознавания к FamilyName
     - Найдено совпадение? → Legacy Match (авто-роль)
     - Не найдено? → Unmatched
```

#### 4.6.3 Статусы семейств

| Статус | Описание | Действия |
|--------|----------|----------|
| 🟢 Up to date | Hash совпадает с библиотекой | — |
| 🟡 Update Available | В библиотеке новая версия | Update |
| 🔵 Legacy Match | Найдено по правилам имени | Update, Stamp (БИМ-менеджер) |
| ⚪ Unmatched | Не найдено | Stamp с ручным выбором роли (БИМ-менеджер) |

#### 4.6.4 Массовые операции

**Update Selected / Update All:**
- Загрузить новые версии из библиотеки
- Применить к существующим элементам в проекте

**Stamp Selected (БИМ-менеджер):**
- Записать клеймо в семейства без клейма
- Для Legacy Match — использовать авто-роль
- Для Unmatched — требуется ручной выбор роли

#### 4.6.5 Производительность

- **Virtual scroll** для таблиц (5000+ семейств)
- **Batch запросы** к бэкенду (не по одному)
- **Кеширование** правил распознавания на клиенте

---

### 4.7 Модуль 7: Отслеживание изменений (Change Tracking)

Модуль для автоматического отслеживания и отображения изменений в семействах (Git-like diff).

#### 4.7.1 Типы отслеживаемых изменений

| Категория | Изменение | Детектирование |
|-----------|-----------|----------------|
| **Имя** | Семейство переименовано | Сравнить FamilyName |
| **Категория** | Изменилась категория Revit | Сравнить Category |
| **Типы** | Добавлен/удалён тип | Сравнить список TypeName |
| **Параметры** | Добавлен/удалён/изменён параметр | Сравнить ParameterName + Value |
| **Геометрия** | Изменилась геометрия | Факт изменения (по Hash) |
| **TXT** | Изменился Type Catalog | Сравнить строки/хеш |

#### 4.7.2 Snapshot (снимок состояния)

При каждом Publish сохраняется JSON-snapshot:

```json
{
  "version": 2,
  "familyName": "FreeAxez_Table_v2",
  "category": "Furniture",
  "types": ["Type_A", "Type_B", "Type_C"],
  "parameters": [
    {"name": "Width", "value": "600", "group": "Dimensions"},
    {"name": "Height", "value": "800", "group": "Dimensions"}
  ],
  "hasGeometryChanges": true,
  "txtHash": "abc123..."
}
```

#### 4.7.3 Local Changes (Stash) — для БИМ-менеджера

**До Publish** БИМ-менеджер видит локальные изменения:

**Статус "Local Modified":**
- Вычисляется при открытии страницы Add to Library
- Текущий Hash ≠ Hash в Extensible Storage → "Local Modified"

**UI в Tab 2:**

| Family Name | Role | Status | Changes | Actions |
|-------------|------|--------|---------|---------|
| FreeAxez_Table | FreeAxez_Table | Local Modified | ✏️➕📝 (3) | [View Changes] [Publish] |

**View Changes modal:**

```
Локальные изменения (не опубликованы):

✏️ Name: "FreeAxez_Table" → "FreeAxez_Table_v2"
➕ Type added: "Type_D" (всего типов: 4)
📝 Parameter changed:
   • Height: 800 → 900
   • Material: "Oak" → "Pine"
🔧 Geometry: изменена

[Discard Changes] [Publish]
```

#### 4.7.4 Changelog — для всех пользователей

**На странице семейства** — история изменений по версиям:

```
Version 3 → Version 4 (2026-02-15 by admin@freeaxez.com)
├── ✏️ Name: "FreeAxez_Table_v2" → "FreeAxez_Table_v3"
├── ➕ Type added: "Type_D"
├── 📝 Parameter changed: "Height" 800 → 900
└── 🔧 Geometry changed

Version 2 → Version 3 (2026-02-10 by bim@freeaxez.com)
├── ➕ Type added: "Type_C"
└── 📝 Parameter changed: "Width" 500 → 600
```

#### 4.7.5 Pre-Update Preview — для Проектировщика

**Перед Update** показываем что изменится:

```
Обновить BaseUnit v2 → v4?

Изменения:
• ✏️ Имя изменено
• ➕ Добавлено 2 типа
• 📝 Изменено 3 параметра
• 🔧 Геометрия обновлена

[Показать детали] [Update] [Cancel]
```

---

### 4.8 Модуль 8: Вложенные семейства (Nested Families)

Модуль для обработки зависимостей между родительскими и вложенными семействами.

#### 4.8.1 Типы вложенности

| Тип | Описание | Shared? | Видно в проекте отдельно? |
|-----|----------|---------|---------------------------|
| **Nested (не Shared)** | Вложено в родительское, не видно снаружи | Нет | Нет — не в расписаниях, не тегируется |
| **Nested Shared** | Вложено, но видно как самостоятельный элемент | Да | Да — в расписаниях, тегируется, свои параметры |

**Ключевое ограничение Revit:**
- Shared семейство, загруженное в проект, не может быть перезаписано на non-shared версию без удаления
- Если Parent_A и Parent_B содержат `Leg_v1` как Shared → в проекте **одна** копия `Leg_v1`
- Обновление `Leg_v1` через одного родителя обновит его и для другого

#### 4.8.2 Правила работы

1. **Каждое Shared вложенное семейство — самостоятельная единица библиотеки** со своей ролью, версией, хешем
2. **Non-Shared вложенные — часть родительского**, не публикуются отдельно
3. **Зависимости хранятся в метаданных** родительского семейства
4. **Порядок загрузки**: вложенные загружаются автоматически при загрузке родительского (Revit делает это сам), но мы контролируем версии

**Должно ли вложенное иметь роль?**

| Тип | Обязательная роль? | Обоснование |
|-----|-------------------|-------------|
| Shared nested | **Рекомендуется** | Видно в проекте, может использоваться отдельно |
| Non-Shared nested | **Нет** | Не видно, не управляется отдельно |

#### 4.8.3 Определение зависимостей через API

**Из загруженного Family в проекте:**
```csharp
Family parentFamily = ...;
Document familyDoc = doc.EditFamily(parentFamily);

FilteredElementCollector collector = new FilteredElementCollector(familyDoc);
IList<Family> nestedFamilies = collector
    .OfClass(typeof(Family))
    .Cast<Family>()
    .ToList();

foreach (Family nested in nestedFamilies)
{
    string name = nested.Name;
    bool isShared = nested.get_Parameter(BuiltInParameter.FAMILY_SHARED)?.AsInteger() == 1;
    // Записать зависимость: parent → nested (shared/not shared)
}
```

#### 4.8.4 Структура данных зависимостей

```json
{
  "familyName": "FreeAxez_Table",
  "roleName": "FreeAxez_Table",
  "dependencies": [
    {
      "familyName": "FreeAxez_Table_Leg",
      "category": "Furniture",
      "isShared": true,
      "roleName": "FreeAxez_Table_Leg",
      "inLibrary": true,
      "libraryVersion": 3
    },
    {
      "familyName": "InternalBracket",
      "category": "Generic Models",
      "isShared": false,
      "roleName": null,
      "inLibrary": false
    }
  ]
}
```

#### 4.8.5 Флоу: Публикация семейства с вложенными

**При Add to Queue:**
```
БИМ-менеджер выбирает FreeAxez_Table в Tab 1 → Add to Queue

1. Плагин анализирует семейство (EditFamily → получить вложенные)
2. Определяет Shared nested families
3. Для каждого Shared nested:
   a. Проверяем ES: есть ли клеймо?
   b. Проверяем библиотеку: есть ли в ней?
   c. Формируем статус зависимости
```

**Отображение в Tab 2:**
```
| ☐ | Family Name          | Role          | Dependencies        | Actions |
|---|----------------------|---------------|---------------------|---------|
| ☐ | FreeAxez_Table       | FreeAxez_Table| ⚠ 2 dependencies    | Stamp   |

При клике на "⚠ 2 dependencies":

Зависимости FreeAxez_Table:
| Nested Family       | Shared | В библиотеке | Статус              |
|---------------------|--------|--------------|---------------------|
| FreeAxez_Table_Leg  | ✅     | ✅ v3         | ✅ Up to date       |
| FreeAxez_Handle     | ✅     | ❌            | ⚠ Не опубликовано   |
| InternalBracket     | ❌     | —            | (non-shared, OK)    |

⚠ Рекомендация: опубликуйте FreeAxez_Handle перед публикацией FreeAxez_Table
```

**При Publish родительского:**
1. Загрузить RFA в Azure Blob
2. Сохранить метаданные + список зависимостей
3. Warning если зависимость не опубликована: "FreeAxez_Handle не опубликован. Пользователи получат версию из RFA-файла."

#### 4.8.6 Хеширование с учётом вложенных

**ParentContentHash = SHA256(NormalizedPartAtomXML(Parent))**

**НЕ включать** содержимое вложенных в хеш родительского:
- Вложенные имеют свои версии и хеши
- Изменение вложенного не должно создавать новую версию родительского
- PartAtom XML содержит **имена** вложенных (если переименовали → хеш изменится, что корректно)

**Когда создавать новую версию родительского:**

| Изменение | Новая версия Parent? |
|-----------|---------------------|
| Изменилась геометрия/параметры Parent | Да |
| Изменилось вложенное Shared семейство | **Нет** (у вложенного своя версия) |
| Добавлено новое вложенное семейство | Да (PartAtom изменится) |
| Удалено/переименовано вложенное | Да (PartAtom изменится) |

#### 4.8.7 Флоу: Загрузка семейства с вложенными в проект

```
Проектировщик нажимает [Load to Project] на FreeAxez_Table v4

1. Плагин проверяет зависимости из метаданных:
   - FreeAxez_Table_Leg → Shared, в библиотеке v3
   - FreeAxez_Handle → Shared, в библиотеке v2

2. Проверяем проект:
   a. FreeAxez_Table_Leg уже есть в проекте?
      - Да, v2 → "В библиотеке v3. Обновить?"
      - Нет → будет загружено вместе с родительским
   b. FreeAxez_Handle уже есть?
      - Нет → будет загружено вместе с родительским

3. Pre-Load Summary:

   Загрузка FreeAxez_Table v4

   Будут загружены:
   • FreeAxez_Table (основное)
   • FreeAxez_Table_Leg (вложенное Shared) — v3
     ⚠ В проекте есть v2. Будет обновлено до v3.
   • FreeAxez_Handle (вложенное Shared) — v1
     Новое, будет загружено впервые.

   [Load All] [Load без обновления вложенных] [Cancel]
```

#### 4.8.8 Конфликт версий вложенных

**Сценарий:** FreeAxez_Table v4 содержит FreeAxez_Table_Leg v3, но в библиотеке Leg уже v5.

```
Вопрос: какую версию Leg загружать?

Решение:
  - При загрузке родительского: загружается версия ИЗ RFA-файла (v3)
  - НО: если в библиотеке есть более новая версия → предложить обновить:

  "FreeAxez_Table_Leg: в RFA вложена v3, но в библиотеке есть v5. Обновить?"

  [Использовать из RFA (v3)] [Обновить из библиотеки (v5)]

При выборе "Обновить из библиотеки":
  1. LoadFamily("Parent.rfa") → загружает Parent + Nested v3 (из RFA)
  2. LoadFamily("Nested_v5.rfa") → перезагружает Nested до v5

Результат: Parent + Nested v5
```

**Порядок загрузки важен:** сначала родительское, потом вложенные (чтобы перезаписать версии из RFA).

#### 4.8.9 IFamilyLoadOptions для контроля загрузки

```csharp
public bool OnSharedFamilyFound(
    Family sharedFamily,
    bool familyInUse,
    out FamilySource source,
    out bool overwriteParameterValues)
{
    // Вложенное Shared найдено — откуда брать?
    // FamilySource.Family = использовать из загружаемого RFA
    // FamilySource.Project = оставить то, что уже в проекте

    if (userChoseLibraryVersion)
    {
        source = FamilySource.Project; // оставить текущую, потом перезапишем
    }
    else
    {
        source = FamilySource.Family; // использовать из RFA
    }

    overwriteParameterValues = true;
    return true;
}
```

#### 4.8.10 Сканер и вложенные семейства

**Как сканер видит вложенные:** Shared вложенные появляются наравне с родительскими в плоском списке.

```
Результат сканирования:
| Family Name          | Category  | Role           | Status           | Nested In      |
|----------------------|-----------|----------------|------------------|----------------|
| FreeAxez_Table       | Furniture | FreeAxez_Table | Update Available | —              |
| FreeAxez_Table_Leg   | Furniture | FreeAxez_Leg   | Update Available | FreeAxez_Table |
| FreeAxez_Handle      | Generic   | FreeAxez_Handle| Up to date       | FreeAxez_Table |
```

**Колонка "Nested In":** показывает в каком родительском используется. Определяется через EditFamily(), кешируется.

**Группировка при Update:**
```
При нажатии [Update] на FreeAxez_Table:

"Обновление FreeAxez_Table также затронет вложенные семейства:
 - FreeAxez_Table_Leg (v2 → v3)
 - FreeAxez_Handle (без изменений)

Обновить всё вместе?"

[Update All] [Update только родительское] [Cancel]
```

#### 4.8.11 UI библиотеки: отображение зависимостей

**На странице семейства:**
```
FreeAxez_Table — Furniture
Version: 4 | Role: FreeAxez_Table

Вложенные семейства (Shared):
| Семейство            │ Категория │ В RFA    │ В библиотеке │
|----------------------|-----------|----------|--------------|
| FreeAxez_Table_Leg   │ Furniture │ v3       │ v5 ↗        |
| FreeAxez_Handle      │ Generic   │ v1       │ v2 ↗        |

↗ = в библиотеке есть более новая версия, чем вложена в RFA
```

**В списке библиотеки:**
- 🔗 — бейдж для семейств с зависимостями
- Tooltip: "Содержит 2 вложенных Shared семейства"

**"Используется в" (обратная связь):**
```
FreeAxez_Table_Leg — Furniture
Version: 5

Используется как вложенное в:
| Родительское         │ Вложена   │ Последняя версия RFA │
|----------------------|-----------|----------------------|
| FreeAxez_Table       │ v3        │ v4                   |
| FreeAxez_WorkDesk    │ v5        │ v2                   |

⚠ В FreeAxez_Table вложена старая версия (v3).
```

#### 4.8.12 Stamp и вложенные

- **Stamp родительского**: записывает ES **только в родительское**
- **Stamp вложенного**: выполняется **отдельно**
- При Stamp родительского → **не** записывать ES в вложенные автоматически

**Рекомендация при Stamp:**
```
При Stamp FreeAxez_Table:

1. Записать ES в FreeAxez_Table
2. Проверить Shared вложенные:
   - FreeAxez_Table_Leg: есть ES? → OK
   - FreeAxez_Handle: нет ES → Info: "Рекомендуется выполнить Stamp отдельно."
3. НЕ блокировать Stamp родительского
```

#### 4.8.13 Edge Cases

| Случай | Решение |
|--------|---------|
| Циклические зависимости | Невозможны в Revit, не обрабатывать |
| Глубокая вложенность (A→B→C) | Рекурсивный обход, Revit загружает автоматически |
| Одно вложенное в нескольких родительских | При обновлении → оба родительских получат обновление (Shared!) |
| Non-Shared стало Shared | ContentHash родительского изменится → новая версия |
| Вложенное без роли | Записать в зависимости с `roleName: null`, не предлагать обновление |

#### 4.8.14 Производительность

**Проблема:** `EditFamily()` — тяжёлая операция (~1-3 сек на семейство).

**Решение:**
- При Publish: определить вложенные, сохранить в метаданные (один раз)
- В проекте: **не** вызывать EditFamily() при сканировании
- Получать зависимости из базы библиотеки по RoleName
- Для Legacy/Unmatched: не определять зависимости

---

## 5. Нефункциональные требования

### 5.1 Производительность

| Метрика | Требование | Контекст |
|---------|------------|----------|
| Сканирование проекта | < 5 сек для 1000 семейств | Плагин, чтение ES + batch запрос |
| Загрузка списка библиотеки | < 2 сек | Фронтенд, пагинация 50 элементов |
| Stamp одного семейства | < 1 сек | Локально, вычисление хеша + запись ES |
| Publish одного семейства | < 10 сек | Загрузка RFA (до 50MB) + метаданные |
| Pull Update одного семейства | < 8 сек | Скачивание + загрузка в Revit |
| Virtual scroll таблиц | 60 FPS | 5000+ строк, PrimeNG Table VirtualScroll |
| Batch проверка статусов | < 3 сек для 500 семейств | API запрос |

### 5.2 Масштабируемость

| Параметр | Значение |
|----------|----------|
| Семейств в библиотеке | до 10,000 |
| Версий на семейство | до 100 |
| Одновременных пользователей | до 50 |
| Размер RFA файла | до 50 MB |
| Размер TXT файла | до 5 MB |
| Размер базы данных | до 100 GB |

### 5.3 Надёжность

- **Offline работа:** Stamp работает без сети, Publish требует сеть
- **Graceful degradation:** При недоступности бэкенда — просмотр локального кеша
- **Retry logic:** 3 попытки при сетевых ошибках с экспоненциальным backoff
- **Atomic operations:** Publish = транзакция (либо всё, либо откат)
- **Backup:** Ежедневный бэкап базы + Blob storage

### 5.4 Безопасность

| Аспект | Решение |
|--------|---------|
| Аутентификация | Azure AD (корпоративный SSO) |
| Авторизация | Role-based (Проектировщик / БИМ-менеджер / Администратор) |
| API security | JWT tokens, HTTPS only |
| Blob access | SAS tokens с ограниченным сроком |
| Audit log | Все операции CRUD логируются (кто, что, когда) |

### 5.5 Совместимость

| Компонент | Версии |
|-----------|--------|
| Revit | 2020, 2021, 2022, 2023, 2024, 2025, 2026 |
| .NET Framework | 4.8 (Revit 2020-2024) |
| .NET | 8 (Revit 2025-2026) |
| WebView2 | Edge Runtime (встроен в Windows 11) |
| Браузеры (автономный режим) | Chrome, Edge, Firefox (последние 2 версии) |

### 5.6 UX требования

- **Время отклика UI:** < 200 мс для интерактивных элементов
- **Loading states:** Skeleton loading для списков, progress bar для загрузок
- **Error messages:** Понятные сообщения + предлагаемое решение
- **Tooltips:** Для всех технических терминов
- **Keyboard navigation:** Полная поддержка Tab/Enter

### 5.7 Error Handling (Revit API)

| Ошибка | Причина | Обработка |
|--------|---------|-----------|
| `LoadFamily()` returns false | Семейство повреждено, несовместимая версия | Error: "Не удалось загрузить семейство. Файл повреждён или несовместим с версией Revit." |
| `EditFamily()` throws | In-Place family, linked model | Skip with info: "In-Place и связанные семейства не поддерживаются" |
| `SetCompoundStructure()` fails | Некорректные данные слоёв (нулевая толщина, нет структурного слоя) | Error с деталями: "Некорректная структура слоёв: [детали]" |
| `Duplicate()` fails for System Type | Нет базового типа в категории | Error: "Невозможно создать тип: в проекте нет базового типа категории [X]" |
| Hash mismatch after load | Файл изменился после скачивания | Warning: "Файл был изменён. Рекомендуется повторная загрузка." |
| ES write fails (Worksharing) | Элемент занят другим пользователем | Warning: "Элемент редактируется [User]. Попробуйте позже." |

### 5.8 Undo / Rollback стратегия

| Операция | Откат |
|----------|-------|
| **Stamp** | Очистить ES (кнопка "Remove Stamp") — редко используется |
| **Publish** | Пометить версию как `Withdrawn = true` — не показывать в списках, но сохранить в истории |
| **Pull Update** | Показать предыдущую версию → скачать → загрузить повторно |
| **Legacy Recognition** | Переопределить роль вручную → Stamp |

**Withdrawn версии:**
- Не отображаются в списках библиотеки
- Доступны через Admin UI (для восстановления)
- Хранятся в Blob (не удаляются)

---

## 6. Критерии успеха (Success Criteria)

### 6.1 Функциональные критерии

| Критерий | Метрика | Цель |
|----------|---------|------|
| Распознавание Legacy семейств | % автоматически распознанных | ≥ 90% |
| Точность правил распознавания | False positives | < 5% |
| Версионирование | % семейств с отслеживаемой версией | 100% |
| Stamp成功率 | % успешных Stamp | ≥ 99% |
| Publish成功率 | % успешных Publish | ≥ 98% |

### 6.2 Продуктовые критерии

| Критерий | Метрика | Цель |
|----------|---------|------|
| Время онбординга | Дни до первого использования | ≤ 1 день |
| Adoption rate | % БИМ-менеджеров использующих систему | ≥ 80% за 3 месяца |
| Reduction in duplicate work | % снижение дубликатов семейств | ≥ 50% |
| User satisfaction | NPS | ≥ 40 |

### 6.3 Технические критерии

| Критерий | Метрика | Цель |
|----------|---------|------|
| Uptime | % доступности API | ≥ 99.5% |
| Bug rate | Критических багов на релиз | < 2 |
| Test coverage | % code coverage backend | ≥ 80% |
| Performance regression | % деградации от baseline | < 10% |

---

## 7. Acceptance Tests

### 7.1 US-A1: Создание ролей семейств

```gherkin
Feature: Создание ролей семейств

Scenario: Одиночное создание роли
  Given Администратор авторизован
  When Создаёт роль с Name="FreeAxez_Table" Description="Стол"
  Then Роль создана
  And Name read-only

Scenario: Пакетное создание через текст
  Given Администратор авторизован
  When Вводит список имён в текстовое поле:
    """
    FreeAxez_Table
    FreeAxez_Chair
    FreeAxez_Lamp
    """
  And Нажимает "Создать"
  Then Создано 3 роли
  And Все с пустым Description

Scenario: Импорт из Excel
  Given Администратор авторизован
  And Excel файл с колонками Name, Type, Description, Category, Tags
  When Загружает файл
  Then Предпросмотр показывает список ролей
  When Подтверждает импорт
  Then Все роли созданы
  And Категории/теги созданы если не существовали

Scenario: Дубликат при создании
  Given Роль "FreeAxez_Table" уже существует
  When Администратор пытается создать роль с Name="FreeAxez_Table"
  Then Дубликат пропущен без ошибки
```

### 7.2 US-A2: Правила распознавания

```gherkin
Feature: Правила распознавания имён

Scenario: Создание правила в Visual mode
  Given Администратор на странице роли "FreeAxez_Table"
  When Добавляет правило: AND(Contains:"Table", Contains:"FreeAxez")
  And Сохраняет
  Then Правило сохранено

Scenario: Формула синхронизируется с Visual
  Given Правило в Visual mode: AND(Contains:"Table", Contains:"FreeAxez")
  When Переключается в Formula mode
  Then Формула показывает: "Table AND FreeAxez"

Scenario: Проверка конфликта
  Given Роль "FreeAxez_Table" с правилом "Table AND FreeAxez"
  And Роль "FreeAxez_Desk" с правилом "Desk AND FreeAxez"
  When Администратор редактирует правило "FreeAxez_Desk" на "Table"
  And Нажимает "Check Conflicts"
  Then Показано предупреждение: "Имя 'FreeAxez_Table' подходит под обе роли"

Scenario: Тест правила
  Given Роль с правилом "(FB OR Desk) AND Wired"
  When Администратор вводит тестовое имя "FB_Field_Wired_v2"
  And Нажимает "Test"
  Then Результат: "Соответствует"
```

### 7.3 US-B1: Управление Loadable Families

```gherkin
Feature: Управление Loadable Families в шаблоне

Scenario: Add to Queue
  Given БИМ-менеджер на Tab 1 "All Families"
  And Семейство "FreeAxez_Table" без клейма
  When Выбирает "FreeAxez_Table"
  And Нажимает "Add to Queue"
  Then Семейство перемещено в Tab 2
  And Draft создан в базе
  And Статус = "New"

Scenario: Stamp
  Given Семейство в Tab 2 со статусом "Role Selected"
  When БИМ-менеджер нажимает "Stamp"
  Then ES записан в семейство (RoleName, ContentHash)
  And Статус = "Stamped"

Scenario: Publish
  Given Семейство в Tab 2 со статусом "Stamped"
  When БИМ-менеджер нажимает "Publish"
  Then RFA загружен в Azure Blob
  And Метаданные сохранены в базе
  And ES обновлен (Version)
  And Draft удалён
  And Семейство перемещено в Tab 3

Scenario: Копирование семейства
  Given "FreeAxez_Table" опубликован в библиотеке
  And Копия "FreeAxez_Table_Copy" содержит тот же ES
  When БИМ-менеджер добавляет копию в Queue
  Then Warning: "Это копия 'FreeAxez_Table'"
  And Варианты: [Пропустить] [Новая роль] [Заменить оригинал]
```

### 7.4 US-B2: Управление System Families

```gherkin
Feature: Управление System Families

Scenario: Publish WallType с CompoundStructure
  Given WallType "Wall_External_200" в Queue
  When БИМ-менеджер нажимает "Publish"
  Then CompoundStructure сериализована в JSON
  And JSON сохранён в базе (нет blob-файлов)
  And ES записан на WallType

Scenario: Pull Update WallType
  Given WallType "Wall_External_200" в проекте (v1)
  And В библиотеке v2 (добавлен слой утеплителя)
  When БИМ-менеджер нажимает "Pull Update"
  Then Warning: "Тип был изменён локально"
  When Подтверждает "Обновить"
  Then CompoundStructure обновлена
  And ES обновлен (Version = 2)

Scenario: Pull Update при отсутствии типа
  Given WallType "Wall_New" НЕ в проекте
  And В библиотеке v1
  When БИМ-менеджер нажимает "Pull Update"
  Then Тип создан через Duplicate от существующего WallType
  And Параметры применены из JSON
```

### 7.5 US-D2: Загрузка семейства в проект

```gherkin
Feature: Загрузка семейства в проект

Scenario: Загрузка без TXT
  Given Проектировщик в библиотеке
  And Семейство "FreeAxez_Table" без TXT
  When Нажимает "Load to Project"
  Then Семейство загружено
  And Все встроенные типы доступны

Scenario: Загрузка с TXT
  Given Семейство "FreeAxez_Table" с TXT (10 типов)
  When Нажимает "Load to Project"
  Then Открылся диалог выбора типов
  When Выбирает 3 типа
  Then Загружены только выбранные типы

Scenario: Загрузка с вложенными
  Given "FreeAxez_Table" содержит Shared вложенное "FreeAxez_Table_Leg"
  And В библиотеке Leg v5, в RFA вложена Leg v3
  When Нажимает "Load to Project"
  Then Pre-Load Summary показывает:
    | Семейство | В RFA | В библиотеке |
    | Leg       | v3    | v5           |
  When Выбирает "Обновить из библиотеки (v5)"
  Then Загружен Parent + Leg v5 (перезаписана v3 из RFA)
```

### 7.6 US-B3: Сканер проектов

```gherkin
Feature: Сканер проектов

Scenario: Сканирование Stamped семейства
  Given Проект содержит "FreeAxez_Table" с ES (RoleName, Hash=ABC)
  And В библиотеке Hash=ABC
  When Пользователь открывает сканер
  Then Статус = "🟢 Up to date"

Scenario: Сканирование Legacy семейства
  Given Проект содержит "Old_Table_v1" без ES
  And Роль "FreeAxez_Table" с правилом "Contains:Table"
  When Пользователь открывает сканер
  Then Статус = "🔵 Legacy Match"
  And Role = "FreeAxez_Table (auto)"

Scenario: Массовое обновление
  Given 10 семейств со статусом "Update Available"
  When Пользователь нажимает "Update All Available"
  Then Все 10 обновлены
  And Progress bar показан
```

---

## 8. TBD: Открытые вопросы и технический долг

### 8.1 Архитектура плагина Revit

#### 8.1.1 Плоская структура команд (Flat Command Structure)

**Правило:** Каждая команда Revit плагина должна иметь **плоскую структуру** без вложенных папок.

**Стандартная структура:**
```
Commands/
└── {CommandName}/
    ├── ViewModels/        # MVVM ViewModels (только если есть UI)
    ├── Views/             # XAML views (только если есть UI)
    ├── Models/            # Domain models, DTOs
    ├── Services/          # Revit API calls, бизнес-логика
    ├── Utils/             # Helpers, extensions
    ├── Enums/             # Enumerations
    └── Converters/        # WPF converters (если нужны)
```

**Decision Tree — какие папки нужны:**
- Есть UI? → Создать `ViewModels/` и `Views/`
- Есть Revit API calls? → Создать `Services/`
- Есть domain models? → Создать `Models/`
- Есть helpers? → Создать `Utils/`
- Есть enums? → Создать `Enums/`
- Есть converters? → Создать `Converters/`

**❌ Запрещено:**
- Вложенные папки (`UI/ViewModels/`, `Core/Services/Implementation/`)
- Пустые папки "на всякий случай"
- Кастомные имена папок (`Infrastructure/`, `Domain/`, `Application/`)

**✅ Пример:**
```
FamilyRoleManagementCommand/
├── ViewModels/
│   ├── RoleEditorViewModel.cs
│   └── RoleListViewModel.cs
├── Views/
│   ├── RoleEditorView.xaml
│   └── RoleListView.xaml
├── Models/
│   └── FamilyRoleModel.cs
├── Services/
│   └── FamilyRoleService.cs
└── Enums/
    └── FamilyStatus.cs
```

#### 8.1.2 Требования к коду (Clean Code)

| Правило | Значение |
|---------|----------|
| Функции | 15-25 строк |
| Классы | 250-350 строк |
| Вложенность | Максимум 2-3 уровня |
| Параметры | 0-2 идеал, 3 допустимо, 4+ → рефакторинг |
| Boolean flags | Запрещены в параметрах |

**Сепарация ответственности:**
- `Models/` — чистый C#, **БЕЗ** Revit API
- `Services/` — **ВЕСЬ** Revit API
- `ViewModels/` — **БЕЗ** Revit API в конструкторе
- `Document` передаётся как параметр метода, не через конструктор

#### 8.1.3 XAML UI требования

**Обязательно:**
- `Window.Style` элемент ПОСЛЕ `Window.Resources`
- `BasedOn="{StaticResource ThemeWindow}"`
- Все элементы со стилями из `AppStyles.xaml`
- Grid-based layout (никаких StackPanel для layout)
- `SizeToContent="Height"`, Width фиксированный

---

## Журнал изменений

| Дата | Изменение |
|------|-----------|
| 2026-02-15 | Создана структура документа по шаблону Spec.txt |
| 2026-02-15 | Перенесены уточнения по Модулю 1 из ТЗ_v2.md |
| 2026-02-15 | Добавлено описание системы (1.1) |
| 2026-02-15 | Добавлены стейкхолдеры и права доступа (1.2) |
| 2026-02-15 | Добавлено описание решаемых проблем (1.3) |
| 2026-02-15 | Добавлена User Story US-A1 (Создание ролей) |
| 2026-02-15 | Добавлена User Story US-A2 (Правила распознавания) |
| 2026-02-15 | Добавлена User Story US-B1 (Управление семействами) |
| 2026-02-15 | Добавлена User Story US-B2 (System Families) |
| 2026-02-15 | Добавлена User Story US-B3 (Сканер) |
| 2026-02-15 | Добавлена User Story US-B4 (Type Catalogs) |
| 2026-02-15 | Добавлены User Stories US-D1, US-D2 (Проектировщик) |
| 2026-02-15 | Заполнены Модули 2-7 в разделе Функциональные требования |
| **2026-02-16** | **ИНТЕГРАЦИЯ: Создан ТЗ_Final_Integrated.md** |
| 2026-02-16 | Добавлена секция 2.3: Интеграционные точки (API контракты) |
| 2026-02-16 | Модуль 3: Добавлены риски ES, Worksharing, онлайн/офлайн Stamp, lifecycle полей |
| 2026-02-16 | Модуль 4: Стратегия хеширования через PartAtom XML, имя НЕ входит в хеш |
| 2026-02-16 | US-B2: Классификация System Families на 5 групп (A-E), JSON-структуры, фазовый план |
| 2026-02-16 | Добавлен Модуль 8: Вложенные семейства (Shared/Non-Shared, зависимости) |
| 2026-02-16 | Заполнена секция 5: Нефункциональные требования |
| 2026-02-16 | Заполнена секция 6: Критерии успеха |
| 2026-02-16 | Заполнена секция 7: Acceptance Tests (Gherkin) |
| **2026-02-16** | **UPDATE: Учтены замечания из ТЗ_Review.md** |
| 2026-02-16 | 4.4.1: Гибридный хеш (PartAtom XML + OLE Streams) вместо только PartAtom |
| 2026-02-16 | 4.3.2: Добавлен fallback при потере ES (серверный маппинг + Legacy Recognition) |
| 2026-02-16 | US-B4: Исправлен алгоритм Type Catalog — плагин парсит TXT сам, вызывает LoadFamilySymbol N раз |
| 2026-02-16 | 5.1: Исправлено React virtualization → PrimeNG Table VirtualScroll |
| 2026-02-16 | US-B1 Drafts: Связь по UniqueId вместо FamilyName |
| 2026-02-16 | 4.2.5: Конфликты правил — warning вместо блокировки, проверка при сканировании |
| 2026-02-16 | 4.4.6: Добавлено поле CommitMessage при Publish |
| 2026-02-16 | US-B2: Маппинг материалов — warning + выбор вместо автоматической заглушки |
| 2026-02-16 | 5.7: Добавлена секция Error Handling (Revit API) |
| 2026-02-16 | 5.8: Добавлена Undo/Rollback стратегия |
| 2026-02-16 | US-B2: Добавлены Spikes/Research перед Phase 1 (PartAtom, OLE, ES Transfer, ES Upgrade) |
| **2026-02-16** | **Добавлена секция 8: TBD (Открытые вопросы)** |
| 2026-02-16 | 8.1.1: Плоская структура команд Revit плагина (Flat Command Structure) |
| 2026-02-16 | 8.1.2: Clean Code требования (15-25 строк функции, 250-350 классы) |
| 2026-02-16 | 8.1.3: XAML UI требования (Grid layout, styles, MVVM) |
| 2026-02-16 | 4.5: Расширен Модуль 5 Type Catalog (UI выбора типов, парсинг TXT, модели данных) |
